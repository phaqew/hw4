
# 第四次作业

### 自动化少61 何奈特 2140506114

---

## 题目一

> 高斯滤波器和中值滤波器平滑test1和test2，分别取模板大小3x3,5x5,7x7

* 这次作业用到了两种新位图格式pgm和tif，继续使用C++处理：

* pgm结构较为简单，（这次用到的都是pgm5型）文件开头是"P5\n"，（然后可能有一个注释行，以'#'开头）下一行有两个ASCII码给出的数字，分别为图像的高和宽（中间用空格隔开），下一行又是一个ASCII码的数字，为最大灰度值。此后就是一行一行的像素灰度数据，而且没有4B对齐的要求。

* tif全名为标签图像文件，典型的tif由文件头、数据、标签三部分依次组成。先从文件头得到标签表的位置（一般放在文件末尾），从该位置读到标签数量，随后读入这么多个12Byte的标签。每个标签由四部分依次组成：ID(2B)、数据类型(2B)、数量(4B)和地址(4B)，小标签（信息量不超过4B）的内容直接放在地址中，不占用数据空间；否则要找到文件的该地址处去取，大小根据数据类型和数量相乘算出。好在对本次任务有用的标签不多：ID为256和257的高和宽（数据直接存放在标签的第四部分），ID为273的带偏移，到其给出的地址可以读到许多个地址，对应图像的很多条“带”，因为都是连续存放的，最简单的做法是从第一个带的地址开始，直接顺序读入高乘宽个字节，对应图像的每个像素灰度值。

* test4.tif尤其复杂，其有多余的采样数据，这一点可以从277号（值为2）和338号（值为1）标签看出（其为每像素采样数和多余采样数，详见[此网站的说明](https://www.awaresystems.be/imaging/tiff/tifftags/samplesperpixel.html)）。另外，pgm和tif存储顺序与bmp上下相反，读入时应颠倒读入。

* 综合考虑以上要素可以写出pgm类和tif类，方便后续的文件读写。更进一步，可以把前面的bmp类也囊括进来，改写这三个类，共同继承于父类Bitmap类，其包含四个成员char *name, int height, int width和BYTE **px，这样大大方便了后续程序的设计，子程序只要接受Bitmap*类型的参数就好了。这些代码详见p1&2\bitmap.cpp

* 高斯滤波的模板如下：（由p1&2\p2.cpp算出）

3*3
-|-|-
:--:|:--:|:--:
0.0947416|0.118318|0.0947416
0.118318|0.147761|0.118318
0.0947416|0.118318|0.0947416

5*5
-|-|-|-|-
:--:|:--:|:--:|:--:|:--:
0.0144188|0.028084|0.0350727|0.028084|0.0144188
0.028084|0.0547002|0.0683123|0.0547002|0.028084
0.0350727|0.0683123|0.0853117|0.0683123|0.0350727
0.028084|0.0547002|0.0683123|0.0547002|0.028084
0.0144188|0.028084|0.0350727|0.028084|0.0144188

7*7
-|-|-|-|-|-|-
:--:|:--:|:--:|:--:|:--:|:--:|:--:
0.00134197|0.00407653|0.00794|0.00991586|0.00794|0.00407653|0.00134197
0.00407653|0.0123834|0.0241196|0.0301217|0.0241196|0.0123834|0.00407653
0.00794|0.0241196|0.0469785|0.0586691|0.0469785|0.0241196|0.00794
0.00991586|0.0301217|0.0586691|0.0732688|0.0586691|0.0301217|0.00991586
0.00794|0.0241196|0.0469785|0.0586691|0.0469785|0.0241196|0.00794
0.00407653|0.0123834|0.0241196|0.0301217|0.0241196|0.0123834|0.00407653
0.00134197|0.00407653|0.00794|0.00991586|0.00794|0.00407653|0.00134197

操作|test1|test2
--|--|--
原图|![](p1&2/test1.bmp)|![](p1&2/test2.bmp)
高斯滤波3|![](p1&2/test1_g3.bmp)|![](p1&2/test2_g3.bmp)
高斯滤波5|![](p1&2/test1_g5.bmp)|![](p1&2/test2_g5.bmp)
高斯滤波7|![](p1&2/test1_g7.bmp)|![](p1&2/test2_g7.bmp)

* 中值滤波计算量大，这里巧用了上次作业第四题写的线段树（见segTree.cpp），添加了mid方法，可以用(log(256))^2次操作求出中位数。（详见p1&2\p2.cpp）

操作|test1|test2
--|--|--
原图|![](p1&2/test1.bmp)|![](p1&2/test2.bmp)
中值滤波3|![](p1&2/test1_m3.bmp)|![](p1&2/test2_m3.bmp)
中值滤波5|![](p1&2/test1_m5.bmp)|![](p1&2/test2_m5.bmp)
中值滤波7|![](p1&2/test1_m7.bmp)|![](p1&2/test2_m7.bmp)

* 中值滤波效果更明显，也即图片的失真更严重。